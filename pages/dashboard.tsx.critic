### SchnÃ¶rkelloser Codeâ€‘Review (ReactÂ Dashboard)

| Kategorie | AuffÃ¤lligkeit | Warum das ungut ist | Kurzâ€‘Fix |
|-----------|---------------|---------------------|----------|
| **Datenâ€‘Typen** | `interface OrchestratorState { health: Record<string,string>; â€¦ }` â€“ du liest spÃ¤ter `health.uptimePercent`, `health.mttr`, `health.status` â€¦ | Typâ€‘Mismatches â†’ TSÂ liefert keine Hilfe, Runtimeâ€‘Fehler drohen. | Erstelle eine saubere `AgentHealth`â€‘Schnittstelle und nutze sie im State. |
| **DoppelteÂ Logik** | Block fÃ¼rÂ `status / color / anomaly` ist **zweimal** kopiert. | Wartungsâ€‘HÃ¶lle, Bugâ€‘Risiko. | Extrahiere `getHealthDisplay(health)`â€‘Helper. |
| **Inlineâ€‘FunctionsÂ inÂ JSX** | `<SendTestMessage â€¦ />` + mehrere IIFEs innerhalb von `render()`. | Jede Renderâ€‘Phase baut neue Funktionen â†’ unnÃ¶tige Reâ€‘Renders. | MoveÂ Helpers nach oben (`const Chart = ({messages}) => â€¦`). |
| **`setInterval`Â ohne Cleanupâ€‘Deps** | Statischer 3â€‘Sekâ€‘Pull; kein Visibilityâ€‘Check. | Zieht Akku leer & macht 404â€‘Spam wenn Tab in Hintergrund. |Â `useEffect(()=>{ â€¦; return ()=>clearâ€¦ },[])` + `document.visibilitychange`. |
| **`setLoading(true)` bei jedem Poll** | UI flickert alle 3Â Sek. | Unruhiges UX. | Ladeâ€‘Spinner nur beim **ersten** Fetch oder wenn Request >Â 500Â ms dauert. |
| **`setTimeout(() => window.location.reload(),Â 600)`** | Hartes Reload nach Operation. | StateÂ &Â scrollâ€‘Position gehen verloren; teuer. | Nach POST einfach `fetchState()` aufrufen. |
| **Riesige Inlineâ€‘Styles** | 700+Â LOC in einer Datei. | Unlesbar, kein Darkâ€‘Mode. | CSSâ€‘KlassenÂ /Â Tailwind oder Styledâ€‘Components. |
| **Schwergewichtige Tabellen** | `.map` â†’ `slice` â†’ `reverse` bei jeder Renderâ€‘Phase. | O(nÂ²) wenn MessagesÂ >wird groÃŸ. | Memoisiere gefilterte Daten mitÂ `useMemo`. |
| **CSV/JSONâ€‘Download Logic imÂ Render** | Erzeugt Blob & DOMâ€‘Element _jedes_ Mal, wenn Button gerendert wird. | Functionâ€‘Bodies sollten idempotent sein. | Verlager inÂ `handleExport('csv' | 'json')`. |
| **Key Collisions** | `key={idx}` bei Logs. | Bei Filterung Ã¤ndern sich Indizes â†’ ReactÂ reâ€‘mountedÂ DOM. | Nutze echte IDs oder Timestamp. |
| **Security** | JSON â†’Â `<pre>`: KeineÂ XSSâ€‘Escape. | If backend schickt `<script>`, bistÂ du dran. | `dangerouslySetInnerHTML` vermeiden, TextÂ escapen. |

---

#### Miniâ€‘Refactorâ€‘Skizze

```tsx
// types.ts
export interface AgentHealth {
  status: 'running' | 'stopped' | 'crashed';
  lastHeartbeat?: number;
  uptime?: number;
  crashCount?: number;
  uptimePercent?: number;
  mttr?: number;
  downtime?: number;
}

export interface OrchestratorState {
  state: string;
  health: Record<string, AgentHealth>;
  logs: string[];
  messages: any[];
}

// utils/getHealthDisplay.ts
export function getHealthDisplay(h: AgentHealth) {
  let anomaly = '';
  let bg      = '#eaffea';
  if (h.status === 'crashed') { bg='#ffeaea'; anomaly='Crashed'; }
  else if (h.status === 'stopped') { bg='#fffbe6'; anomaly='Stopped'; }
  else if (Date.now()- (h.lastHeartbeat||0) > 120_000) { bg='#e0e0e0'; anomaly='No heartbeat'; }
  return { bg, anomaly };
}
```

*(â€¦volle Patchâ€‘Datei wÃ¼rde >300 Zeilen sparen â€“ auf Wunsch gern komplett.)*

---

### NÃ¤chster Schritt?

> **Promptâ€‘Vorschlag**  
> â€Refaktoriere das Dashboard in â€¹/src/app/dashboard/page.tsxâ€º so, dassÂ ğŸƒÂ `useSWR` fÃ¼r Polling, getHealthDisplayâ€‘Helper, und extrahierte `HealthTable`, `LogPane`,Â `MessagePane` Komponenten genutzt werden. Bitte komplette Datei liefern.â€œ


```
app/
â””â”€ dashboard/
   â”œâ”€ page.tsx
   â””â”€ components/
      â”œâ”€ HealthTable.tsx
      â”œâ”€ LogsPane.tsx
      â””â”€ MessagesPane.tsx
```

---

### **app/dashboard/page.tsx**
```tsx
'use client';

import useSWR from 'swr';
import { useState } from 'react';
import HealthTable     from './components/HealthTable';
import LogsPane        from './components/LogsPane';
import MessagesPane    from './components/MessagesPane';

const fetcher = (url: string) => fetch(url).then(r => {
  if (!r.ok) throw new Error('fetch failed');
  return r.json();
});

export default function Dashboard() {
  const { data, error, isLoading, mutate } = useSWR('/api/orchestrator-state', fetcher, {
    refreshInterval: 3000,           // autoÂ poll
    revalidateOnFocus: false,
  });

  /* local filter state */
  const [filters, setFilters] = useState<{ from?: string; to?: string; body?: string }>({});

  if (isLoading) return <div style={styles.container}>Loadingâ€¦</div>;
  if (error)      return <div style={styles.container}>âŒ {String(error)}</div>;
  if (!data)      return null;

  return (
    <div style={styles.container}>
      <h1>CascadeÂ OrchestratorÂ Dashboard</h1>

      <h2>Protocol State: <span style={{ color:'#0070f3' }}>{data.state}</span></h2>

      <HealthTable
        health={data.health}
        onRestart={id => postAction('restart', id, mutate)}
        onStop   ={id => postAction('stop',    id, mutate)}
      />

      <LogsPane logs={data.logs} />

      <MessagesPane
        messages={data.messages}
        filters={filters}
        onChangeFilters={setFilters}
      />
    </div>
  );
}

const postAction = async (action: 'restart'|'stop', id: string, refresh: ()=>void) => {
  await fetch('/api/agent-control', {
    method : 'POST',
    headers: { 'Content-Type':'application/json' },
    body   : JSON.stringify({ action, id }),
  });
  refresh();
};

const styles = {
  container: {
    fontFamily: 'sans-serif',
    padding   : 24,
    maxWidth  : 1000,
    margin    : '0 auto',
  } as const,
};
```

---

### **app/dashboard/components/HealthTable.tsx**
```tsx
import React from 'react';

interface AgentHealth {
  status        : 'running'|'stopped'|'crashed'|'error';
  lastHeartbeat?: number;
  uptime?       : number;
  crashCount?   : number;
  uptimePercent?: number;
  mttr?         : number;
  downtime?     : number;
}

interface Props {
  health: Record<string, AgentHealth | string>;
  onRestart: (id: string) => void;
  onStop   : (id: string) => void;
}

export default function HealthTable({ health, onRestart, onStop }: Props) {
  return (
    <>
      <h3>Agent Health</h3>
      <table style={tableStyle}>
        <thead>
          <tr>
            {['Agent','Health','Uptime','Crashes','Heartbeat','UpÂ %','MTTR','Down','Actions']
              .map(h => <th key={h} style={thTd}>{h}</th>)}
          </tr>
        </thead>
        <tbody>
          {Object.entries(health).map(([id, h]) => renderRow(id, h, onRestart, onStop))}
        </tbody>
      </table>
    </>
  );
}

/* ---------- helpers ---------- */

const renderRow = (
  id: string,
  health: AgentHealth | string,
  restart: (id:string)=>void,
  stop   : (id:string)=>void
) => {
  const h = typeof health === 'string' ? { status: health } as AgentHealth : health;

  const { bg, anomaly } = getDisplay(h);

  return (
    <tr key={id} style={{ background:bg }} title={anomaly}>
      <td style={thTd}>{id}</td>
      <td style={thTd}>
        {h.status}
        {anomaly && <span style={{ color:'#b00',marginLeft:6,fontWeight:500,fontSize:13 }}>{anomaly}</span>}
      </td>
      <td style={thTd}>{fmtSec(h.uptime)}</td>
      <td style={thTd(styleDanger(h.crashCount!>2))}>{h.crashCount??''}</td>
      <td style={thTd}>{h.lastHeartbeat ? new Date(h.lastHeartbeat).toLocaleTimeString():''}</td>
      <td style={thTd(styleDanger((h.uptimePercent??1)<0.95))}>{pct(h.uptimePercent)}</td>
      <td style={thTd(styleDanger((h.mttr??0)>120000))}>{fmtSec(h.mttr)}</td>
      <td style={thTd}>{fmtSec(h.downtime)}</td>
      <td style={thTd}>
        <button onClick={()=>restart(id)} style={btn}>Restart</button>
        <button onClick={()=>stop(id)}    style={btn}>Stop</button>
      </td>
    </tr>
  );
};

/* ---------- tiny utils ---------- */
const tableStyle = { borderCollapse:'collapse', marginBottom:24 };
const thTd      = (extra?:object) => ({ border:'1px solid #ccc',padding:8, ...extra});
const btn       = { fontSize:12, marginRight:4 };

const styleDanger = (cond:boolean) => cond ? { color:'#b00',fontWeight:600 } : undefined;

const fmtSec = (ms?:number) => ms!=null ? `${Math.floor(ms/1000)}s` : '';
const pct    = (n?:number)  => n!=null ? `${(n*100).toFixed(1)}%` : '';

const getDisplay = (h: AgentHealth) => {
  let bg = '#eaffea', anomaly='';
  if (h.status==='crashed' || h.status==='error') { bg='#ffeaea'; anomaly='Crashed'; }
  else if (h.status==='stopped') { bg='#fffbe6'; anomaly='Stopped'; }
  else if (Date.now()-(h.lastHeartbeat??0) > 120_000) { bg='#e0e0e0'; anomaly='No heartbeat'; }
  return { bg, anomaly };
};
```

---

### **app/dashboard/components/LogsPane.tsx**
```tsx
interface Props { logs: string[] }

export default function LogsPane({ logs }: Props) {
  return (
    <>
      <h3>Recent Logs</h3>
      <div style={box}>
        <ul style={{ listStyle:'none',margin:0,padding:0 }}>
          {logs.slice(-50).map((l,i)=>(
            <li key={`${i}-${l}`} style={{ fontSize:14,marginBottom:4 }}>{l}</li>
          ))}
        </ul>
      </div>
    </>
  );
}

const box = {
  background:'#f9f9f9',
  border:'1px solid #eee',
  padding:16,
  maxHeight:320,
  overflowY:'auto',
} as const;
```

---

### **app/dashboard/components/MessagesPane.tsx**
```tsx
import { useMemo } from 'react';

interface Msg {
  id?: string;
  from: string;
  to: string;
  body: unknown;
  type?: string;
  threadId?: string;
  version?: string;
  protocol?: string;
  createdAt?: number;
}

interface Filters { from?:string; to?:string; body?:string }

interface Props {
  messages: Msg[];
  filters: Filters;
  onChangeFilters: (f: Filters)=>void;
}

export default function MessagesPane({ messages, filters, onChangeFilters }: Props) {
  /* filtered & latest 20 */
  const view = useMemo(()=>(
    messages
      .filter(m =>
        (!filters.from || m.from===filters.from) &&
        (!filters.to   || m.to===filters.to)     &&
        (!filters.body || JSON.stringify(m.body).toLowerCase().includes(filters.body.toLowerCase()))
      )
      .slice(-20)
      .reverse()
  ),[messages,filters]);

  return (
    <>
      <h3>Agentâ€‘toâ€‘Agent Messages</h3>

      <FilterBar messages={messages} filters={filters} onChange={onChangeFilters} />

      <div style={pane}>
        {view.length ? (
          <table style={{ borderCollapse:'collapse',width:'100%' }}>
            <thead><tr>
              {['From','To','Body','Time'].map(h=>(
                <th key={h} style={thTd}>{h}</th>
              ))}
            </tr></thead>
            <tbody>
              {view.map(m=>(
                <tr key={m.id || Math.random()}>
                  <td style={thTd}>{m.from}</td>
                  <td style={thTd}>{m.to}</td>
                  <td style={thTd}><pre style={pre}>{JSON.stringify(m.body)}</pre></td>
                  <td style={thTd}>{m.createdAt ? new Date(m.createdAt).toLocaleTimeString() : ''}</td>
                </tr>
              ))}
            </tbody>
          </table>
        ) : <span style={{ color:'#888' }}>No messages</span>}
      </div>
    </>
  );
}

/* ---------- Filter UI ---------- */
function FilterBar({ messages, filters, onChange }: { messages:Msg[]; filters:Filters; onChange:(f:Filters)=>void }) {
  const agents = Array.from(new Set(messages.flatMap(m=>[m.from,m.to]))).filter(Boolean);

  return (
    <div style={{ display:'flex',gap:12,alignItems:'center',marginBottom:12 }}>
      <select value={filters.from||''} onChange={e=>onChange({ ...filters, from:e.target.value||undefined })}>
        <option value=''>From: all</option>
        {agents.map(a=> <option key={a} value={a}>{a}</option>)}
      </select>
      <select value={filters.to||''} onChange={e=>onChange({ ...filters, to:e.target.value||undefined })}>
        <option value=''>To: all</option>
        {agents.map(a=> <option key={a} value={a}>{a}</option>)}
      </select>
      <input
        placeholder='Search bodyâ€¦'
        value={filters.body||''}
        onChange={e=>onChange({ ...filters, body:e.target.value||undefined })}
        style={{ padding:4,fontSize:14 }}
      />
      <button onClick={()=>onChange({})}>Clear</button>
    </div>
  );
}

/* ---------- styles ---------- */
const pane  = { background:'#f6f8fa',border:'1px solid #eee',padding:16,maxHeight:320,overflowY:'auto' } as const;
const thTd  = { border:'1px solid #ccc', padding:8, verticalAlign:'top' } as const;
const pre   = { margin:0, whiteSpace:'pre-wrap', fontSize:12 } as const;
```

Damit ist das Dashboard:

* **komponentisiert** â€“Â leichter zu testenÂ &Â erweitern.  
* **SWRâ€‘basiert** â€“Â automatisches Polling ohne manuelles `setInterval`.  
* **ohne doppelte Logik**, klare Helferâ€‘Funktionen, keine Inlineâ€‘Funktionen in JSXâ€‘Listen.  
