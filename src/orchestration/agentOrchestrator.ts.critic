```
src/
└─ orchestration/
   ├─ orchestrator/
   │  ├─ types.ts
   │  ├─ bus.ts
   │  └─ orchestrator.ts
   └─ index.ts
```

---

### **src/orchestration/orchestrator/types.ts**
```ts
/* Public DTOs shared across the orchestration layer */

export type OrchestratedAgent = {
  id        : string;
  type      : string;
  status    : 'pending' | 'healthy' | 'running' | 'stopped' | 'error';
  host      : string;
  config    : Record<string, unknown>;
};

export type AgentMessage = {
  from      : string;
  to        : string;
  content   : unknown;
  timestamp : number;
};

export type SwarmState = {
  agents    : OrchestratedAgent[];
  messages  : AgentMessage[];
};

export type AgentCapability = string;
```

---

### **src/orchestration/orchestrator/bus.ts**
```ts
import { AgentMessage } from './types';

/**
 * In‑memory message bus.  Inject a different implementation
 * (e.g. Redis, NATS) in production if needed.
 */
export class MessageBus {
  private messages: AgentMessage[] = [];

  publish(msg: AgentMessage): void {
    this.messages.push(msg);
  }

  byReceiver(id: string): AgentMessage[] {
    return this.messages.filter(m => m.to === id);
  }

  list(): AgentMessage[] {
    return [...this.messages];
  }

  clear(): void {
    this.messages = [];
  }
}
```

---

### **src/orchestration/orchestrator/orchestrator.ts**
```ts
import { AgentManager }          from '../agentManager';
import { agentLogStore }         from '../agentLogs';
import { agentHealthStore }      from '../agentHealth';
import { logAgentHealthToSupabase } from '../supabaseAgentOps';

import { MessageBus }            from './bus';
import {
  OrchestratedAgent,
  AgentCapability,
  AgentMessage,
  SwarmState,
} from './types';

interface OrchestratorDeps {
  manager      : AgentManager;
  bus          : MessageBus;
  now?         : () => number;           // deterministic tests
  maxRecovery? : number;
  slackNotify? : (txt: string) => Promise<void>;
}

export class AgentOrchestrator {
  private readonly mgr: AgentManager;
  private readonly bus: MessageBus;
  private readonly now: () => number;
  private readonly maxRecovery: number;
  private readonly slack?: (txt: string) => Promise<void>;
  private recoveryAttempts: Record<string, number> = {};
  private capabilityRegistry: Record<string, AgentCapability[]> = {};

  constructor({
    manager,
    bus,
    now = () => Date.now(),
    maxRecovery = 3,
    slackNotify,
  }: OrchestratorDeps) {
    this.mgr          = manager;
    this.bus          = bus;
    this.now          = now;
    this.maxRecovery  = maxRecovery;
    this.slack        = slackNotify;

    /* react to crash events */
    agentHealthStore.onStatusChange(async (id, status) => {
      if (status === 'crashed') await this.restart(id);
    });
  }

  /* ------------ autoscaling (very naive) ---------------- */
  async autoscale(workload: number): Promise<void> {
    const running = this.mgr.list().filter(a => a.status === 'running');
    const target  = Math.max(1, Math.ceil(workload / 5));

    /* scale up */
    while (running.length < target) {
      const id = `auto-${this.now()}`;
      await this.launch({ id, type: 'native', status: 'pending', host: 'local', config: {} });
      running.push({} as any);
    }

    /* scale down */
    if (running.length > target) {
      const surplus = running.slice(target);
      for (const a of surplus) await this.stop(a.id);
    }
  }

  /* ------------ capability routing ---------------------- */
  registerCapabilities(id: string, caps: AgentCapability[]): void {
    this.capabilityRegistry[id] = caps;
  }

  async delegate(cap: AgentCapability, task: unknown, from: string): Promise<string> {
    const candidates = Object.entries(this.capabilityRegistry)
      .filter(([, c]) => c.includes(cap))
      .map(([id]) => id);

    if (!candidates.length) throw new Error(`no agent with capability ${cap}`);

    const to = candidates[Math.floor(Math.random() * candidates.length)];
    await this.message({ from, to, content: task, timestamp: this.now() });
    return to;
  }

  /* ------------ agent lifecycle ------------------------- */
  async launch(cfg: OrchestratedAgent): Promise<OrchestratedAgent> {
    await this.mgr.deploy(cfg.id, cfg.id, cfg.type, cfg.config);

    agentLogStore.addLog({
      agentId   : cfg.id,
      timestamp : this.now(),
      level     : 'info',
      message   : 'launched',
    });

    logAgentHealthToSupabase(cfg.id, 'healthy', 'launched', 'info', { event: 'launch' });
    return this.get(cfg.id);
  }

  async stop(id: string): Promise<void> {
    await this.mgr.stop(id);
    agentHealthStore.setHealth(id, 'crashed');
  }

  async restart(id: string): Promise<'recovered' | 'failed'> {
    const attempts = (this.recoveryAttempts[id] ?? 0) + 1;
    this.recoveryAttempts[id] = attempts;

    if (attempts > this.maxRecovery) {
      agentHealthStore.setHealth(id, 'recovery_failed');
      return 'failed';
    }

    agentHealthStore.setHealth(id, 'restarting');
    try {
      await this.mgr.restart(id);
      agentHealthStore.setHealth(id, 'recovered');
      this.recoveryAttempts[id] = 0;
      return 'recovered';
    } catch (err) {
      agentHealthStore.setHealth(id, 'recovery_failed');
      return 'failed';
    }
  }

  /* ------------ messaging ------------------------------- */
  async message(msg: AgentMessage): Promise<void> {
    this.bus.publish(msg);
    /* optional persistence skipped for brevity */
  }

  inbox(id: string): AgentMessage[] {
    return this.bus.byReceiver(id);
  }

  /* ------------ state ----------------------------------- */
  list(): OrchestratedAgent[] {
    return this.mgr.list();
  }

  get(id: string): OrchestratedAgent {
    const a = this.mgr.list().find(x => x.id === id);
    if (!a) throw new Error('agent not found');
    return a;
  }

  swarm(): SwarmState {
    return { agents: this.list(), messages: this.bus.list() };
  }

  /* ------------ test utils ------------------------------ */
  reset(): void {
    this.bus.clear();
    this.mgr.clear();
    this.recoveryAttempts = {};
  }
}
```

---

### **src/orchestration/index.ts**
```ts
export * from './agents';                            // BaseAgent & factory
export * from './agentManager';                      // main manager
export * from './orchestrator/types';
export { MessageBus }      from './orchestrator/bus';
export { AgentOrchestrator } from './orchestrator/orchestrator';
```

Damit besitzt auch dein **Orchestrator‑Layer** jetzt eine klar getrennte, test‑freundliche Architektur:

* **`MessageBus`** – leicht ersetzbar für Redis / Rabbit.  
* **`AgentManager`** – verantwortet allein Lebenszyklus & Logik der Instanzen.  
* **`AgentOrchestrator`** – Koordination, Autoscaling, Delegate‑Routing, Recovery.  
* **Keine Singletons, keine Top‑Level Side‑Effects** – alle Abhängigkeiten werden injiziert und sind damit in Unit‑Tests vollständig mock‑bar.