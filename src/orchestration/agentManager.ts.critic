```
src/
â””â”€ orchestration/
   â”œâ”€ agents/
   â”‚  â”œâ”€ BaseAgent.ts
   â”‚  â”œâ”€ factory.ts
   â”‚  â””â”€ index.ts
   â””â”€ agentManager.ts
```

---

### **src/orchestration/agents/BaseAgent.ts**
```ts
import { EventEmitter } from 'events';

export type AgentStatus = 'running' | 'stopped' | 'healthy' | 'error';

export interface Heartbeat {
  ts: number;
  type: 'heartbeat';
}

export interface LogEntry {
  ts: number;
  msg: string;
}

export interface AgentLike extends EventEmitter {
  id: string;
  name: string;
  status: AgentStatus;
  start(): void;
  stop(): void;
  getLogs(): string[];
}

export class BaseAgent extends EventEmitter implements AgentLike {
  id: string;
  name: string;
  status: AgentStatus = 'stopped';
  private beatTimer?: NodeJS.Timeout;
  private _logs: LogEntry[] = [];

  constructor(id: string, name: string) {
    super();
    this.id   = id;
    this.name = name;
  }

  /* -------------------------------------------------- */
  start(): void {
    this.status = 'running';
    this.log('Agent started');
    this.emit('heartbeat', { ts: Date.now(), type: 'heartbeat' } as Heartbeat);

    this.beatTimer = setInterval(() => {
      this.emit('heartbeat', { ts: Date.now(), type: 'heartbeat' });
      this.log('Agent heartbeat');
    }, 5_000);
  }

  /* -------------------------------------------------- */
  stop(): void {
    if (this.beatTimer) clearInterval(this.beatTimer);
    this.status = 'stopped';
    this.log('Agent stopped');
  }

  /* -------------------------------------------------- */
  log(msg: string): void {
    this._logs.push({ ts: Date.now(), msg });
    // keep lastÂ 50
    if (this._logs.length > 50) this._logs = this._logs.slice(-50);
  }

  getLogs(): string[] {
    return this._logs.map(l => `[${new Date(l.ts).toISOString()}] ${l.msg}`);
  }
}
```

---

### **src/orchestration/agents/factory.ts**
```ts
import { BaseAgent, AgentLike } from './BaseAgent';

/* Lazy imports keep optional deps out of critical path */
export function createAgent(
  id: string,
  name: string,
  type: string,
  cfg: Record<string, unknown> = {}
): AgentLike {
  switch (type) {
    case 'langchain': {
      const LangChainAgent = require('./langChainAgent').default;
      return new LangChainAgent(id, cfg);
    }
    case 'autogen': {
      const AutoGenAgent = require('./autoGenAgent').default;
      return new AutoGenAgent(id, cfg);
    }
    default:
      return new BaseAgent(id, name);
  }
}
```

---

### **src/orchestration/agents/index.ts**
```ts
export * from './BaseAgent';
export { createAgent } from './factory';
```

---

### **src/orchestration/agentManager.ts**
```ts
import {
  AgentLike,
  AgentStatus,
  createAgent,
} from './agents/index';

export interface AgentInfo {
  id: string;
  name: string;
  status: AgentStatus;
  instance: AgentLike;
  type: string;
  config: Record<string, unknown>;
  lastHeartbeat: number;
  lastActivity: number;
  crashCount: number;
}

export interface PersistencePort {
  load(id: string): Promise<Record<string, unknown> | null>;
  save(id: string, snapshot: Record<string, unknown>): Promise<void>;
}

/**
 * Pureâ€‘logic manager â€“ no singletons, no sideâ€‘effects.
 * Inject Storage + Time provider for easy unit testing.
 */
export class AgentManager {
  private agents = new Map<string, AgentInfo>();

  constructor(
    private readonly storage?: PersistencePort,
    private readonly now: () => number = () => Date.now()
  ) {}

  /* --------------------------------- deploy -------------------------------- */
  async deploy(
    id: string,
    name: string,
    type: string = 'native',
    cfg: Record<string, unknown> = {}
  ): Promise<AgentInfo> {
    /* replace if exists */
    if (this.agents.has(id)) await this.stop(id);

    const persisted = (await this.storage?.load(id)) ?? {};
    const mergedCfg = { ...cfg, ...persisted };

    const agent = createAgent(id, name, type, mergedCfg);
    agent.start();

    /* wire heartbeat listener */
    agent.on('heartbeat', () => {
      const rec = this.agents.get(id);
      if (rec) rec.lastHeartbeat = this.now();
    });

    const info: AgentInfo = {
      id,
      name,
      status: 'healthy',
      instance: agent,
      type,
      config: mergedCfg,
      lastHeartbeat: this.now(),
      lastActivity : this.now(),
      crashCount   : 0,
    };

    this.agents.set(id, info);
    return info;
  }

  /* ---------------------------------- stop --------------------------------- */
  async stop(id: string): Promise<void> {
    const rec = this.agents.get(id);
    if (!rec) return;
    rec.instance.stop();
    rec.status       = 'stopped';
    rec.lastActivity = this.now();
    await this.storage?.save(id, {
      status: rec.status,
      config: rec.config,
      stoppedAt: this.now(),
    });
  }

  /* -------------------------------- restart -------------------------------- */
  async restart(id: string): Promise<AgentInfo> {
    const rec = this.agents.get(id);
    if (!rec) throw new Error('agent not found');
    await this.stop(id);
    return this.deploy(id, rec.name, rec.type, rec.config);
  }

  /* ------------------------- health / monitoring --------------------------- */
  health(id: string): AgentStatus | 'not-found' {
    const rec = this.agents.get(id);
    if (!rec) return 'not-found';

    const age = this.now() - rec.lastHeartbeat;
    if (rec.status === 'running' && age > 15_000) {
      rec.status = 'error';
      rec.crashCount += 1;
    }
    return rec.status;
  }

  logs(id: string): string[] {
    const rec = this.agents.get(id);
    return rec ? rec.instance.getLogs() : [];
  }

  list(): AgentInfo[] {
    return Array.from(this.agents.values());
  }

  /* -------------------------------- tests ---------------------------------- */
  clear(): void {
    for (const rec of this.agents.values()) rec.instance.stop();
    this.agents.clear();
  }
}
```

---

## Highlights des RefactorsÂ ðŸ’¡

* **Null Sideâ€‘Effects** â€“ kein `global Map`, keine `setInterval`â€‘Abzweigungen auÃŸerhalb von Klassen.
* **Dependencyâ€‘Injection**:  
  *Â Persistenzâ€Layer (`PersistencePort`) undÂ `Date.now`Â werden injiziertÂ â†’Â einfachÂ mockâ€‘bar.  
* **Events statt Polling** â€“Â `BaseAgent` emittiert `heartbeat`, Manager lauscht darauf.
* **Saubere Trennung** â€“Â `factory.ts` kennt alle konkreten Agentâ€‘Typen, `AgentManager` nur die abstrakteÂ API.
* **Kompakte Tests** â€“Â jedes StÃ¼ck Logik testest du ohne echte Timer oder I/O, z.B.:

```ts
import { AgentManager } from '@/orchestration/agentManager';

test('marks agent as crashed when heartbeat stale', async () => {
  const fakeNow = jest.fn()
    .mockReturnValue(0)       // deploy
    .mockReturnValue(30_000); // health check

  const mgr = new AgentManager(undefined, fakeNow);
  await mgr.deploy('a1', 'Alpha');
  const status = mgr.health('a1');
  expect(status).toBe('error');
});
```

Damit ist dein Agentenâ€‘Subsystem genauso schlank und testâ€‘freundlich wie der Telegramâ€‘Endpoint.